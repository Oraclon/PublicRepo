import math;

class Datastruct:
    def __init__(self):
        self.featDim  : float = 0;
        self.dataDim  : float = 0;
        self.innerDim : float = 0;
        self.dataItems: list[float] = [];
        self.ready: bool = False;
    def InsertKernel(self, kernel: list[float]) -> None:
        if not self.ready:
            arrDim: int = int(math.sqrt(len(kernel)));
            self.featDim = arrDim;
            self.dataDim = arrDim;
            self.innerDim = arrDim * arrDim;
            self.ready = True;
        self.dataItems = kernel;
    def RangeByIndex(self, indexPos: int) -> list[float]:
        collection: list[float] = [];
        for pos in range(self.featDim):
            if(pos < self.featDim):
                location: int = (indexPos * self.featDim) + pos;
                collection.append(self.dataItems[location]);
            else:
                break;
        return collection;

def ApplyFilterOnPosition(pos: int, pixels: list[float], dts: Datastruct) -> (bool, bool, list[float]):
    imDim = int(math.sqrt(len(pixels)));
    breakStep: bool = False;
    breakLoop: bool = False;
    results: list[float] = [];
    
    for i in range(dts.featDim):
        p: int = (i * imDim) + pos;
        key: int = 0;
        for j in range(p, p+dts.featDim,1):
            calc: float = pixels[j] * dts.RangeByIndex(i)[key];
            results.append(calc);
            key += 1;
        
            if (pos != 0) and ((j + 1) % imDim == 0):
                breakStep = True;
            if (pos != 0) and ((j + 1) == len(pixels)):
                breakLoop = True;
    return (breakStep, breakLoop, results);

dts: Datastruct = Datastruct();
dts.InsertKernel([1,1,1, 0,0,0, -1,-1,-1])

array = [x for x in range(64)]
imDim = int(math.sqrt(len(array)))
collection: list[float] = [];
multiplier: int = 1;
position: int = -1;
for i in range(len(array)):
    position += 1;
    breakStep, breakLoop, result = ApplyFilterOnPosition(position, array, dts);
    collection.append(sum(result));

    if breakLoop:
        break;
    if breakStep:
        position = ((imDim * 1) * multiplier)-1;
        multiplier += 1;
        pass
    
    
pass
